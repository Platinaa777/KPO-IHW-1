# Приложение для работников кинотеатра

## Функциональность приложения:

  1. Возможность фиксации продажи посетителям кинотеатра билетов на сеанс с
  выбором мест.
  2. Реализация возможности возврата проданных билетов посетителям до начала
  сеанса.
  3. Возможность отображения свободных и проданных мест для выбранного
  сеанса.
  4. Возможность редактирования данных о фильмах, находящихся в прокате
  кинотеатра, и расписания сеансов их показа.
  5. Возможность отметки занятых мест в зале посетителями конкретного сеанса.
  6. Реализация простого функционала регистрации пользователей с обязательным
  шифрованием паролей и авторизации пользователей (работников) при входе

## Структура проекта:

### Проект выполнен с использованием Clean Architecture 

  #### Слои:

  1. *core* - Здесь находятся основные сущности и интерфейсы для работы с ними, которые не зависят от конкретной реализации.
  2. *infrasturucture* - находятся внешние зависимости в нашем случае бд, использующая json (class CinemaRepository реализующий
  интерфейс из ядра и содержащий логику доступа к базе данных)
  3. *application* - уровень бизнес-логики (в этом приложении он просто прокидывается дальше через ResponseDataHandler), но для дальнейшей разработки,
  возможно, нам бы понадобился брокер-сообщений, появилась бы какая-нибудь функциональность с деньгами и скидками на билет (вся эта логика была бы в этом уровне, получается сделал
  больше вклад в будущее)
  4. *main* - точка входа в программу (как бы уровень представления)

  #### Подробно о каждом слое:
  
  *core*: содержит в папке models сущности, которые хранятся в бд (film -> session), также есть сам контракт для работы с этими данными ICinemaRepository
  
  *application*: содержит обработчик ответов от уровня данных, классы отвечающие за бизнес-логику и различные промежуточные сущности
  
  *infrastructure*: есть класс, реализующий интерфейс ICinemaRepository -> CinemaRepository, который уже обращается к самому контексту данных (DataContext). Также
  здесь хранятся сущности для самой бд (SessionJSON - отличается от обычного сеанса тем, что у него временное поле в тип String). Присутствует класс Seed, который 
  наполняет бд данными (тк было бы странно иметь кинотеатр без фильмов), есть Mapper данных, который кастит объекты из бд в объекты domain (core)
  
  *main*: есть какие-то обычные utils помогающие соблюдать принцип DRY, DI - региструрующий зависимости, main - точка входа

  *extra: infrastructure.auth*: сервис для регистрации пользователей, содержит свои сущности и utils.


## Почему выбран JSON?

#### Читаемость и простота:
JSON имеет человекочитаемый формат, что делает его легко читаемым как для разработчиков, так и для других систем.
Форматирование данных в JSON позволяет легко воспринимать информацию и делает файлы удобными для ручного редактирования при необходимости.

#### Легкость использования:
JSON хорошо поддерживается в различных языках программирования, включая Kotlin (пакет kotlin-serialization).
Существуют библиотеки для работы с JSON, которые упрощают чтение и запись данных из/в файлы JSON.

#### Поддержка структурированных данных:
JSON поддерживает структурированные данные с различными уровнями вложенности (как в вашем примере с фильмами, сеансами и статусами мест).
Это позволяет удобно организовывать информацию и представлять связанные данные в виде объектов.
