# Приложение для работников кинотеатра

# Диаграмма UML - https://drive.google.com/file/d/19C7CKpyJyy9beBv94IsTZ6l4ldB6vbrw/view?usp=sharing

## Функциональность приложения:

  1. Возможность фиксации продажи посетителям кинотеатра билетов на сеанс с
  выбором мест.
  2. Реализация возможности возврата проданных билетов посетителям до начала
  сеанса.
  3. Возможность отображения свободных и проданных мест для выбранного
  сеанса.
  4. Возможность редактирования данных о фильмах, находящихся в прокате
  кинотеатра, и расписания сеансов их показа.
  5. Возможность отметки занятых мест в зале посетителями конкретного сеанса.
  6. Реализация простого функционала регистрации пользователей с обязательным
  шифрованием паролей и авторизации пользователей (работников) при входе

## Структура проекта:

### Проект выполнен с использованием Clean Architecture 

  #### Слои:

  1. *core* - Здесь находятся основные сущности и интерфейсы для работы с ними, которые не зависят от конкретной реализации.
  2. *infrastructure* - находятся внешние зависимости в нашем случае бд, использующая json, содержаться классы FilmRepositoryImpl,
  TicketRepositoryImpl, SessionRepositoryImpl, которые имеют свою зону ответственности за определенные модели данных (ticket, session, film)
  4. *application* - уровень бизнес-логики класс CinemaService, который реализует интерфейсы CinemaPartService, TicketService, на этом уровне данные из
  репозиториев как-то обрабатываются и складываются в единое целое для дальнейшей передачи в уровень представления
  6. *main* - точка входа в программу (как бы уровень представления)

  #### Подробно о каждом слое:
  
  *core*: содержит в папке models сущности, которые хранятся в бд (film, session, ticket), также есть сам контракты для работы с этими данными: TicketRepository,
  FilmRepository, SessionRepository
  
  *application*: содержит обработчик ответов от уровня данных(ResponseDataHandler), классы отвечающие за бизнес-логику и различные промежуточные сущности(FilmInfo, SessionInfo, SessionWithFilmData)
  
  *infrastructure*: есть класс, реализующий интерфейс реализующие интерфейсы из core для работы с билетами, сеансами и фильмами, эти реализации под собой уже имеют класс DataContext - база данных. Также
  здесь хранятся сущности для самой бд (SessionJSON - отличается от обычного сеанса тем, что у него временное поле в тип String). Присутствует класс Seed, который 
  наполняет бд данными (тк было бы странно иметь кинотеатр без фильмов), есть Mapper данных, который кастит объекты из бд в объекты domain (core), также есть функции для какой-либо обработки и join'а объектов по id
  
  *main*: есть какие-то обычные utils помогающие соблюдать принцип DRY, DI (App, Configuration.Kt)- региструрующий зависимости, main - точка входа

  *extra: infrastructure.auth*: сервис для регистрации пользователей, содержит свои сущности и utils.


## Почему выбран JSON?

#### Читаемость и простота:
JSON имеет человекочитаемый формат, что делает его легко читаемым как для разработчиков, так и для других систем.
Форматирование данных в JSON позволяет легко воспринимать информацию и делает файлы удобными для ручного редактирования при необходимости. (папка data/*,  сделал красивое 
форматирование json объектов)

#### Легкость использования:
JSON хорошо поддерживается в различных языках программирования, включая Kotlin (пакет kotlin-serialization).
Существуют библиотеки для работы с JSON, которые упрощают чтение и запись данных из/в файлы JSON.

#### Поддержка структурированных данных:
JSON поддерживает структурированные данные с различными уровнями вложенности (как в нашем примере с фильмами, сеансами и статусами мест).
Это позволяет удобно организовывать информацию и представлять связанные данные в виде объектов.
То есть если кинотеатр будет расширяться по местам, то json отлично для этого подойдет
